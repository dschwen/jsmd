<!DOCTYPE HTML>
<html lang="en">
  <head>
    <title>jsMD example</title>
    <meta charset="utf-8">
    <script type="text/javascript" src="../render3d.js"></script>
    <script type="text/javascript" src="../vector3d.js"></script>
    <script type="text/javascript" src="../linkcell3d.js"></script>
    <script type="text/javascript" src="../neighborlist3d.js"></script>
    <script type="text/javascript" src="../jsmd.js"></script>
    <script type="text/javascript" src="../lib/Three.js"></script>
    <script type="text/javascript" src="../lib/jquery.pack.js"></script>
    <script type="text/javascript" src="../lib/jquery.flot.min.js"></script>
    <script src="../lib/MathJax/MathJax.js">
      MathJax.Hub.Config({
        extensions: ["tex2jax.js","TeX/bbox.js"],
        imageFont: null,
        //menuSettings: { zoom: 'Hover' },
        jax: ["input/TeX","output/HTML-CSS"],
        tex2jax: {inlineMath: [["$","$"],["\\(","\\)"]]}
      });
    </script>
    <style>
      div.box { border: 1px solid gray; margin: 0.2em; padding: 0.2em; }
      #step1,#step2,#step3 {
        border: 1px dotted blue;
        background-color: #eeeeee;
        padding: 0.5em;
      }
      h1 { font-family: sans; }
      #step2 { display: none }
      #step3 { display: none }
  
      .radiooff, .radiooff p { color: gray; }
      div.radioon { border: 1px solid black }
    </style>
  </head>
  <body>
    <!-- Step 1: choose system geometry -->
    <div id="step1">
      <h1>Sample geometry</h1>
      <p>Select a sample geometry from the list below.</p>
      <select id='geometry'>
        <option value="0">fcc crystal</option>
        <option value="0">nano particle</option>
        <option value="0">gas</option>
      </select>
      <button onclick="gostep(1,2)">Next</button>
    </div>               

    <!-- Step 1: choose interaction potential -->
    <div id="step2">
      <h1>Atomic interactions</h1>
      <p>Select an interaction potential and its parameters.</p>
      <div class="box radioon">
        <input type="radio" name="potential" onchange="updateRadios('#step2')" checked/> 
        <b>No interaction</b> (ideal gas)</br>
      </div>
      <div class="box radiooff">
        <input type="radio" name="potential" onchange="updateRadios('#step2')"/>
        <b>Lennard Jones</b> pair potential</br>
        <p>\[ 
            V(r)=4 \varepsilon \left[ \left( \frac {\sigma} {r} \right)^{12} - \left( \frac {\sigma} {r} \right)^6 \right]
        \]</p>
        $\varepsilon=$ <input type="number" value="1.0" id="ljepsilon"/> (binding energy)<br/>
        $\sigma=$ <input type="number" value="1.295" id="ljsigma"/> (length scale, $2^{\frac16}\sigma=r_m$ is equilibrium dimer separation distance)<br/>
        $r_{cut}=$ <input type="number" value="3.5" id="ljsigma"/> (all atomic interactions beyond $r_{cut}$ are ignored. recommended: $r_{cut}\approx2.5\sigma$)
      </div>
      <button onclick="gostep(2,1)">Back</button>
      <button onclick="gostep(2,3)">Next</button>
    </div>

    <!-- Step 3: run stuff -->
    <div id="step3">
      <h1>Simulation</h1>
      <div id="simcan" style="widthL 600px; height: 600px" style="float: left"></div>
      <div id="plot" style="width: 500px; height: 450px; float: right"></div>
      <div style="width: 500px">
        <button onclick="heat()">Add heat</button>
        <button onclick="cool()">Remove heat</button>
        <button onclick="addvac()">Add vacancy</button><br/>
        <input id="ramp" type="checkbox" onclick="ramp(this)"><label for="ramp">Auto ramp-up</label>
        <div class="box">
          <input id="baro" type="checkbox" onclick="sim.computeChain[4] = this.checked ? barostat : null">
          <label for="baro">Activate barostat</label>
          <input type="number" value="10.0" onchange="baropt.P0=this.value"/>
          <input type="number" value="100.0" onchange="baropt.tau=this.value"/>
        </div>
        <div class="box">
          <input id="therm" type="checkbox" onclick="sim.computeChain[5] = this.checked ? thermostat : null">
          <label for="therm">Activate thermostat</label>
          <input type="number" value="0.5" onchange="thermopt.T0=this.value"/>
          <input type="number" value="0.1" onchange="thermopt.tau=this.value"/>
        </div>
        <input id="draw" type="checkbox" onclick="toggledraw(this)" checked><label for="draw">Update visuals</label>
        <div><i>T = <span id="showT"></span></i> energy units</div>
        <div><i>P = <span id="showP"></span></i> pressure units</div>
      </div>
      <div style="width: 50%; float: left; height: 200px; overflow:scroll; border: 1px solid gray"><pre id="log"></pre></div>
      <button onclick="gostep(3,2)">Back</button>
    </div>

    <script type="text/javascript">

      var jsmd = initJSMD(3),
          ss = 10, sv = new jsmd.Vector(ss,ss,ss),
          sc = $('#simcan'),
          sim = new jsmd.Simulation(sv),
          t, c = 0, a, p = new jsmd.Vector, x, y, i,
          T = 0.0, P = 0.0, Q = 0.0,
          count = 0, rcount = 0, rup = false, vup = true,
          logp = $('#log'),
          showT = $('#showT'),
          showP = $('#showP'),
          tab_tofq = [], tab_voft = [], tab_poft = [];

      function updateRadios(sel) {
        $(sel).find('.radioon').addClass('radiooff').removeClass('radioon');
        $(sel).find('.radiooff').has('input:radio:checked').addClass('radioon').removeClass('radiooff');
      }

      function gostep(n1,n2) {
        $('#step'+n1).hide(400);
        switch( n1 ) {
          case 1: 
            geo = 0;
            // construct simulation object 
            break;
          case 2:
            // set interaction matrix and compute chain
            break;
          case 3:
            // initialize render3d (container must not be hidden!)
        }
        $('#step'+n2).show(400);
      }

      t = new jsmd.AtomType();
      t.r = 0.25;
      sim.types.push(t);
      t = new jsmd.AtomType();
      t.r = 0.25;
      t.m = 1;
      t.color = 'rgb(0,200,0)';
      sim.types.push(t);

      // insert atoms
      var fcc = [[0,0,0],[1,1,0],[1,0,1],[0,1,1]];
      for( x = 0; x < ss/2; ++x ) {
        for( y = 0; y < ss/2; ++y ) {
          for( z = 0; z < ss/2; ++z ) {
            for( n = 0; n < 4; ++n ) {
              p.x = (2*x+fcc[n][0])+0.5;
              p.y = (2*y+fcc[n][1])+0.5;
              p.z = (2*z+fcc[n][2])+0.5;
              a = new jsmd.Atom(p);
              a.p.wrap(sv);
              a.v.x = 0.5*(Math.random()-0.5);
              a.v.y = 0.5*(Math.random()-0.5);
              a.v.z = 0.5*(Math.random()-0.5);
              sim.atoms.push(a);
            }   
          }
        }
      }

      //sim.setCutOff(4.0,0.5);
      sim.setCutOff(3.5,0.5);

      // tabulate the morse potential with all default options
      //var force = jsmd.force.tabulated( jsmd.force.morse(1.28) );
      var force = jsmd.force.tabulated( jsmd.force.lennardJones(1.295, 1.0) );

      sim.setInteraction( [0,0], force );
      sim.setInteraction( [1,0], force );
      sim.setInteraction( [1,1], force );
      sim.nl.update();
      sim.drag = 1.0;

      var render3d = initRender3D( sim, document.getElementById('simcan') );
      sim.renderChain = [ ];

      // w and w/o barostat
      var baropt = { P0: 0.0, tau: 10.0 },
          barostat = jsmd.compute.berendsenP( baropt ),
          thermopt = { T0: 0.5, tau: 0.1 },
          thermostat = jsmd.compute.thermostat( thermopt );
      sim.computeChain = [ 
        jsmd.compute.verlet1,    // [0]
        jsmd.compute.wrapUpdate, // [1]
        jsmd.compute.forces,     // [2]
        jsmd.compute.verlet2,    // [3]
        null,                    // [4]
        null                     // [5]
      ];

      //sim.dt = 0.1;
      sim.pkapos = [];
      setInterval( function() {
        var it;
      
        for( it = 0; ( !vup && it < 20 ) || ( vup && it == 0 ); ++it ) {
          sim.run(2);
          if( vup ) { render3d(); }
          count++;
          P += sim.P;
          T += sim.T;
          if( count > 10 ) {
            P = Math.round(10000*P/count)/10000;
            T = Math.round(10000*T/count)/10000;
            showP.text(P);
            showT.text(T);
            count = 0;
            rcount++;
            if( rup && rcount > 20 ) {
              log.innerHTML += Q + ' ' + T + ' ' + P + ' ' + sim.ss.vol() + "\n";
              tab_tofq.push([Q,T]);
              tab_poft.push([T,P]);
              tab_voft.push([T,sim.ss.vol()]);
              $.plot( $('#plot'), [ { data: tab_voft, color : 'rgb(200,0,0)', label : 'T(Q)' } ] );
              rcount = 0;
              Q += heat();
            }
            P = 0.0;
            T = 0.0;
          }
        }
      }, 1000/50 );

      // add heat to the system
      function heat() {
        var Q = 0.0, tm = 0.0, cm = new jsmd.Vector();
        for( i = 0; i < sim.atoms.length; i++ ) {
          a = sim.atoms[i];
          v2 = -a.v.len2();
          a.v.x += 0.5*(Math.random()-0.5);
          a.v.y += 0.5*(Math.random()-0.5);
          a.v.z += 0.5*(Math.random()-0.5);
          v2 += a.v.len2();
          Q += sim.types[a.t].m * v2;
  
          // obtain center of mass momentum
          cm.add( jsmd.Vector.scale(a.v,sim.types[a.t].m) );
          tm += sim.types[a.t].m;
        }

        // subtract center of mass momentum
        cm.scale(1.0/tm);
        for( i = 0; i < sim.atoms.length; i++ ) {
          sim.atoms[i].v.sub(cm);
        }

        // return average energy added per atom
        return 0.5 * ( Q + tm*cm.len2() ) / sim.atoms.length;
      }
      // remove heat from the system
      function cool() {
        var Q = 0.0;
        for( i = 0; i < sim.atoms.length; i++ ) {
          a = sim.atoms[i];
          v2 = -a.v.len2();
          a.v.zero();
          Q += sim.types[a.t].m * v2;
        }

        // return average energy added per atom
        return Q/sim.atoms.length;
      }
      // toggle temperature ramping
      function ramp(box) {
        rup = box.checked;
      }
      // toggle visual update
      function toggledraw(box) {
        vup = box.checked;
      }
      // toggle barostat
      function toggleBarostat(box) {
        sim.computeChain[4] = box.checked ? barostat : null;
      }
      // remove random atom to create a vacancy
      function addvac () { 
        sim.atoms.splice( Math.floor( Math.random() * sim.atoms.length ), 1 );
        sim.nl.update();
      }


    </script>
  </body>
</html>
