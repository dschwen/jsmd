<!DOCTYPE HTML>
<html lang="en">
  <head>
    <title>jsMD example</title>
    <meta charset="utf-8">
    <script type="text/javascript" src="../render3d.js"></script>
    <script type="text/javascript" src="../vector3d.js"></script>
    <script type="text/javascript" src="../linkcell3d.js"></script>
    <script type="text/javascript" src="../neighborlist3d.js"></script>
    <script type="text/javascript" src="../jsmd.js"></script>
    <script type="text/javascript" src="../lib/Three.js"></script>
    <script type="text/javascript" src="../lib/jquery.pack.js"></script>
    <script src="../lib/MathJax/MathJax.js">
      MathJax.Hub.Config({
        extensions: ["tex2jax.js","TeX/bbox.js"],
        imageFont: null,
        //menuSettings: { zoom: 'Hover' },
        jax: ["input/TeX","output/HTML-CSS"],
        tex2jax: {inlineMath: [["$","$"],["\\(","\\)"]]}
      });
    </script>
    <style>
      div.box { 
        border: 1px solid gray; margin: 5px; padding: 5px;
        -moz-box-shadow: 5px 5px 5px #ccc;
        -webkit-box-shadow: 5px 5px 5px #ccc;
        box-shadow: 5px 5px 5px #ccc;
      }
      .right { margin-left: 510px !important }

      div.green { background-color: #aaffaa }
      div.blue { background-color: #aaaaff }
      .width100 {
        width: 100%;
        -moz-box-sizing: border-box;
        -webkit-box-sizing: border-box;
        box-sizing: border-box;
      }
      
      #step1,#step2,#step3 {
        border: 1px dotted blue;
        background-color: #eeeeee;
        padding: 0.5em;
      }
      h1 { font-family: sans; }
      #step2 { display: none }
      #step3 { display: none }
  
      /*.radiooff, .radiooff p { color: gray; }*/
      div.radioon { border: 1px solid black }
      .radiooff { opacity: 0.35 }
    </style>
  </head>
  <body>
    <!-- Step 1: choose system geometry -->
    <div id="step1">
      <h1>Sample geometry</h1>
      <p>Select a sample geometry and boundary conditions.</p>
      <div style="width: 45%; float: left">
      	<div class="box radioon">
          <input value="fcc" type="radio" name="sample" onchange="updateRadios('#step1')" checked id="sam_fcc"/> 
          <label for="sam_fcc"><b>Crystalline solid</b> (face centered cubic lattice)</label></br>
          $d=$ <input type="number" value="8" id="crboxsize"/> (crystal size $d\times d\times d$ unit cells )
      	</div>
      	<div class="box radiooff">
          <input value="nano" type="radio" name="sample" onchange="updateRadios('#step1')" id="sam_nano"/> 
          <label for="sam_nano"><b>Nano particle</b></label></br>
          $r=$ <input type="number" value="3" id="npradius"/> (radius)
      	</div>
      	<div class="box radiooff">
          <input value="gas" type="radio" name="sample" onchange="updateRadios('#step1')" id="sam_gas"/> 
          <label for="sam_gas"><b>Gas</b></label></br>
          $N=$ <input type="number" value="1000" id="sgnum"/> (number of atoms)<br/>
          $T=$ <input type="number" value="1.0" id="sgtemp"/> (temperature)<br/>
          $L=$ <input type="number" value="40.0" id="sglen"/> (box size, $V=L^3$)<br/>
      	</div>
      </div>
      <div style="width: 45%; float: right">
      	<div class="box radioon">
          <input value="period" type="radio" name="boundary" onchange="updateRadios('#step1')" checked id="bc_period"/> 
          <label for="bc_period"><b>Periodic boundaries</b></label></br>
          <canvas id="bc_can_period" style="float: right; border: 1px solid black" width="50" height="50"></canvas>
	  <br style="clear: both"/>
      	</div>
      	<div class="box radiooff">
          <input value="reflect" type="radio" name="boundary" onchange="updateRadios('#step1')" id="bc_reflect"/> 
          <label for="bc_reflect"><b>Reflecting boundaries</b></label></br>
          <canvas id="bc_can_reflect" style="float: right; border: 1px solid black" width="50" height="50"></canvas>
	  <br style="clear: both"/>
      	</div>
      </div>
      <br style="clear: both"/>
      <button onclick="gostep(1,2)">Next</button>
    </div>               

    <!-- Step 2: choose interaction potential -->
    <div id="step2">
      <h1>Atomic interactions</h1>
      <p>Select an interaction potential and its parameters.</p>
      <div class="box radioon">
        <input value="none" type="radio" name="potential" onchange="updateRadios('#step2')" checked id="pot_none"/> 
        <label for="pot_none"><b>No interaction</b> (ideal gas)</label></br>
      </div>
      <div class="box radiooff">
        <input value="lj" type="radio" name="potential" onchange="updateRadios('#step2')" id="pot_lj"/>
        <label for="pot_lj"><b>Lennard Jones</b> pair potential</label></br>
        <p>\[ 
            V(r)=4 \varepsilon \left[ \left( \frac {\sigma} {r} \right)^{12} - \left( \frac {\sigma} {r} \right)^6 \right]
        \]</p>
        $\varepsilon=$ <input type="number" value="1.0" id="ljepsilon"/> (binding energy)<br/>
        $\sigma=$ <input type="number" value="1.295" id="ljsigma"/> (length scale, $2^{\frac16}\sigma=r_m$ is equilibrium dimer separation distance)<br/>
        $r_{cut}=$ <input type="number" value="3.5" id="ljsigma"/> (all atomic interactions beyond $r_{cut}$ are ignored. recommended: $r_{cut}\approx2.5\sigma$)
      </div>
      <button onclick="gostep(2,1)">Back</button>
      <button onclick="gostep(2,3)">Next</button>
    </div>

    <!-- Step 3: run stuff -->
    <div id="step3">
      <h1>Simulation</h1>
      <div class="box" style="height: 600px" id="simcan"></div>
      <div style="width: 500px; float: left">
        <div class="box green">
          <button onclick="heat()">Add heat</button>
          <button onclick="cool()">Remove heat</button>
          <button onclick="addvac()">Add vacancy</button><br/>
        </div>

        <div id="pistonbox" class="box">
          <input id="piston" type="checkbox" onclick="pistonOpt.on=this.checked">
          <label for="piston">Move piston</label><br/>
          max<sub>z</sub>=<input type="number" value="80.0" onchange="pistonOpt.max=this.value"/>
          min<sub>z</sub>=<input type="number" value="20.0" onchange="pistonOpt.min=this.value"/><br/>
          v<sub>z</sub>=<input id="pistonvz" type="number" value="0.2" step="0.1" onchange="pistonOpt.sv.z=this.value"  />
          <button onclick="pistonOpt.sv.z *=-1; $('#pistonvz').val(pistonOpt.sv.z)">Reverse</button>
        </div>
<!--
        <div class="box">
          <input id="ramp" type="checkbox" onclick="ramp(this)">
          <label for="ramp">Auto ramp-up</label><br/>
          Plot <select id="plottype">
            <option value="0">Temperatue vs. added heat T(Q)</option>
            <option value="1">Heatcapacity vs. Temperature c(T)</option>
            <option value="2">Volume vs. Temperature V(T)</option>
            <option value="3">Presure vs. Temperature P(T)</option>
          </select>
        </div>
-->
        <div class="box green">
          <input id="ploton" type="checkbox" onclick="ploton=this.checked">
          <label for="ploton">Gather and plot data</label>
          <button onclick="addPoint(); replot()">Plot</button>
          <button onclick="clearTabs(); replot()">Clear</button>
          <br/>
          Plot 
          <select id="plottypeY" onchange="replot()">
            <option value="0" selected>Temperatue</option>
            <option value="1">Work performed by piston (atomic)</option>
            <option value="2">Work performed by piston (p dV)</option>
            <option value="3">Added heat</option>
            <option value="4">Heatcapacity</option>
            <option value="5">Volume</option>
            <option value="6">Pressure</option>
            <option value="7">Simulation step</option>
            <option value="8">Simulation time</option>
            <option value="9">Work performed by thermostat</option>
            <option value="10">Work performed by barostat</option>
          </select>
          vs. 
          <select id="plottypeX" onchange="replot()">
            <option value="0">Temperatue</option>
            <option value="1">Work performed by piston (atomic)</option>
            <option value="2">Work performed by piston (p dV)</option>
            <option value="3">Added heat</option>
            <option value="4">Heatcapacity</option>
            <option value="5">Volume</option>
            <option value="6" selected>Pressure</option>
            <option value="7">Simulation step</option>
            <option value="8">Simulation time</option>
            <option value="9">Work performed by thermostat</option>
            <option value="10">Work performed by barostat</option>
          </select>
          <button onclick="getRawData(true)">Get data</button>
        </div>

        <div class="box">
          <input id="baro" type="checkbox" onclick="sim.computeChain[4] = this.checked ? barostat : null">
          <label for="baro">Activate barostat</label><br/>
          P<sub>0</sub>=<input type="number" value="0.0" onchange="baropt.P0=this.value"/>
          &tau;=<input type="number" value="100.0" onchange="baropt.tau=this.value"/>
        </div>

        <div class="box">
          <input id="therm" type="checkbox" onclick="sim.computeChain[5] = this.checked ? thermostat : null">
          <label for="therm">Activate thermostat</label><br/>
          T<sub>0</sub>=<input type="number" value="0.5" step="0.1" onchange="thermopt.T0=this.value"/>
          &tau;=<input type="number" value="0.1" onchange="thermopt.tau=this.value"/>
        </div>

        <div class="box green">
          Get raw data for
          <select id="datatype">
            <option value="vel">Atom velocities</option>
            <option value="pos">Atom positions</option>
          </select>
          <button onclick="getRawData(false)">Go</button>
        </div>

        <div class="box blue">
          <div><i>T = <span id="showT"></span></i> energy units</div>
          <div><i>P = <span id="showP"></span></i> pressure units</div>
        </div>
      </div>
      <div class="box right" id="logbox" style="display: none; position: relative">
        <textarea id="log" style="height: 300px" class="width100" wrap="off"></textarea>
        <button onclick="$('#logbox').hide(400)">Ok</button>
        <a style="position: absolute; right:1em" id="logdl" target="data" download="data.txt" href="">Download data..</a>
      </div>
      <div id="plotbox" class="box right">
        <div id="plot" style="width: 100%; height: 450px;"></div>
      </div>
      <br style="clear: both"/>
      <button onclick="gostep(3,2)">Back</button>
    </div>

    <script type="text/javascript">

      var jsmd = initJSMD(3),
          ss, sv,
          sc = $('#simcan'),
          sim, force,
          t, c = 0, a, p = new jsmd.Vector, x, y, i,
          averages = {}, rup = false,
          logp = $('#log'),
          showT = $('#showT'),
          showP = $('#showP'),
          render3d, stopAnim, stopCompute, ploton = false,
          compOpt = { samples: 40, equilibrate: 20, loopSteps: 1 }, 
          pistonOpt = { max: 80, min: 20.0, sv: new jsmd.Vector(0,0,0.2), on: false, U: 0.0, PdV: 0.0 },
          reqAnim = window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame,
          tabs;

      // initialization code
      $(function() {
        // make sure the box highlighting corresponds to the radio button state (some browseres restore forms)
        updateRadios('#step1');

        // duplicate the onchange hander into click handler for input[type=number] elements
        // workaround for http://code.google.com/p/chromium/issues/detail?id=51836
        $('input[type=number]').each( function(i,e) { if( e.onclick == null ) { e.onclick=e.onchange; } } );
        
        // start animations for boundary condition selection
        bcvis.start();
        
        // initialize plotting data tables
        clearTabs();
      });

      function gostep(n1,n2) {
        var x,y,z,n,p = new jsmd.Vector(),
            fcc = [[0,0,0],[1,1,0],[1,0,1],[0,1,1]];
        $('#step'+n1).hide(400);
        switch( n1 ) {
          case 1: 
            // construct simulation object 
            switch( $('input:radio[name=sample]:checked').val() ) {
              case 'fcc' : 
                ss = Math.round($('#crboxsize').val()); 
                sv = new jsmd.Vector(ss,ss,ss);
                sim = new jsmd.Simulation(sv);

                // insert atoms
                for( x = 0; x < ss/2; ++x ) {
                  for( y = 0; y < ss/2; ++y ) {
                    for( z = 0; z < ss/2; ++z ) {
                      for( n = 0; n < 4; ++n ) {
                        p.x = (2*x+fcc[n][0])+0.5;
                        p.y = (2*y+fcc[n][1])+0.5;
                        p.z = (2*z+fcc[n][2])+0.5;
                        a = new jsmd.Atom(p);
                        a.p.wrap(sv);
                        a.v.x = 0.5*(Math.random()-0.5);
                        a.v.y = 0.5*(Math.random()-0.5);
                        a.v.z = 0.5*(Math.random()-0.5);
                        sim.atoms.push(a);
                      }   
                    }
                  }
                }
                break;
              case 'nano' :
                var r = $('#npradius').val(), r2=r*r, half;
                ss = r*8.0; 
                sv = new jsmd.Vector(ss,ss,ss);
                half = jsmd.Vector.scale(sv,0.5);
                sim = new jsmd.Simulation(sv);
                // insert atoms
                for( x = -ss/4; x < ss/4; ++x ) {
                  for( y = -ss/4; y < ss/4; ++y ) {
                    for( z = -ss/4; z < ss/4; ++z ) {
                      for( n = 0; n < 4; ++n ) {
                        p.x = (2*x+fcc[n][0])+0.5;
                        p.y = (2*y+fcc[n][1])+0.5;
                        p.z = (2*z+fcc[n][2])+0.5;
                        if( p.len2() <= r2 ) {
                          p.add(half)
                          a = new jsmd.Atom(p);
                          a.p.wrap(sv);
                          a.v.x = 0.5*(Math.random()-0.5);
                          a.v.y = 0.5*(Math.random()-0.5);
                          a.v.z = 0.5*(Math.random()-0.5);
                          sim.atoms.push(a);
                        }
                      }   
                    }
                  }
                }
                break;
              case 'gas' :
                var num = $('#sgnum').val(),
                    temp = $('#sgtemp').val(),
                    i,w,x1,x2,v2 = 0.0,gr=[];
                ss = $('#sglen').val();
                sv = new jsmd.Vector(ss,ss,ss);
                sim = new jsmd.Simulation(sv);

                // assign gaussian distributed velocities
                for( n = 0; n < num; ++n ) {
                  // fill gaussian random number reservoir
                  if( n%2 == 0 ) {
                    for( i = 0; i<3; ++i ) {
                      do {
                              x1 = 2.0 * Math.random() - 1.0;
                              x2 = 2.0 * Math.random() - 1.0;
                              w = x1 * x1 + x2 * x2;
                      } while ( w >= 1.0 );

                      w = Math.sqrt( (-2.0 * Math.log( w ) ) / w ); // TODO: consider mass in a two atom gas!
                      gr[2*i] = x1 * w;
                      gr[2*i+1] = x2 * w;
                    }
                  }
                     
                  // create atom at random position, with gaussian velocity distribution
                  a = new jsmd.Atom( jsmd.Vector.random(sv) );
                  a.v.x = gr[(n%2)*3];
                  a.v.y = gr[(n%2)*3+1];
                  a.v.z = gr[(n%2)*3+2];
                  v2 += a.v.len2() * 1.0; // TODO: mass assumed to be 1.0
                  sim.atoms.push(a);
                }

                // rescale to desired temperature
                w = Math.sqrt( sim.atoms.length * temp / (0.5 * v2 ) );
                for( n = 0; n < num; ++n ) {
                  sim.atoms[n].v.scale(w);
                }
                break;
            }
            t = new jsmd.AtomType();
            t.r = 0.25;
            sim.types.push(t);

            // add entry for heat influx/outflux
            sim.work.heat = 0.0;

            // set compute chain
            sim.computeChain = [ 
              jsmd.compute.verlet1,    // [0]
              // PBC or reflect
              ($('input:radio[name=boundary]:checked').val() == 'period') ? jsmd.compute.wrap : computeMovingWall, // [1]
              null               ,     // [2] computeForces
              jsmd.compute.verlet2,    // [3]
              null,                    // [4]
              null                     // [5]
            ];

            // delete existing visualization
            $('#simcan').empty();

            // initialize render3d (container must not be hidden!)
            $('#step3').css( { display: "block", visibility: "hidden" } )
            render3d = initRender3D( sim, $('#simcan')[0] );
            $('#step3').css( { display: "none", visibility: "visible" } )
      
            // stop little animations
            bcvis.stop();

            // show/hide pistion box depending on BC
            if( $('input:radio[name=boundary]:checked').val() == 'period' ) {
              $('#pistonbox').hide();
              pistonOpt.on=false;
            } else {
              $('#pistonbox').show();
              pistonOpt.on=$('#piston')[0].checked;
            }
            break;
          case 2:
            switch( $('input:radio[name=potential]:checked').val() ) {
              case 'none' : 
                // set cut-off
                sim.computeChain[2] = null;
                sim.setCutOff(8,0.5);
                break;

              case 'lj' : 
                // tabulate the potential with all default options
                force = jsmd.potential.tabulated( jsmd.potential.lennardJones(1.295, 1.0) );

                // set interaction matrix (1x1)
                sim.computeChain[2] = jsmd.compute.forces;
                sim.setInteraction( [0,0], force );

                // set cut-off
                sim.setCutOff(3.5,0.5);
                break;
            }
            sim.nl.update();

            // misc
            sim.drag = 1.0;
            sim.renderChain = [ ];
            break;
          case 3:
            stopAnim();
            stopCompute();
            break;
        }
        switch( n2 ) {
          case 1:
            bcvis.start();
            break;
          case 2: 
            updateRadios('#step2');
            break
          case 3: 
            stopAnim = startAnim();
            stopCompute = startCompute();
            break;
        }
        $('#step'+n2).show(400);
      }


      // w and w/o barostat
      var baropt = { P0: 0.0, tau: 100.0 },
          barostat = jsmd.compute.berendsenP( baropt ),
          thermopt = { T0: 0.5, tau: 0.1 },
          thermostat = jsmd.compute.thermostat( thermopt );

      function startAnim() {
        var keepRunning, handler;
        function frame() {
          render3d();
          if( keepRunning ) { reqAnim(frame); }
        }
        if( reqAnim ) {
          keepRunning = true;
          frame();
        } else {
          keepRunning = false;
          handler = setInterval( render3d, 50 );
        }

        // return a function to stop the animation
        return function() { 
          if( keepRunning  ) { 
            keepRunning = false;
          } else {
            clearInterval( handler );
          }
        }
      }

      var runningAverage = {
        buffer : [],
        index : 0,
        _num : 20,
        addPoint: function() {
          this.buffer[this.index++] = { P: sim.P, T: sim.T }
          if( this.index >= this._num ) {
            this.index = 0;
          }
        },
        average: function() {
          var i, a = { P: 0.0, T: 0.0 }, c = 0;
          for( i = 0; i < this.buffer.length && i < this._num; ++i ) {
            a.P += this.buffer[i].P;
            a.T += this.buffer[i].T;
            c++;
          }
          a.P /= c;
          a.T /= c;
          return a;
        },
        setNum: function(num) {
          this.buffer = [];
          this.index = 0;
          this._num = num;
          this.addPoint();
        }
      }
      function clearTabs() {
        tabs = [ [],[],[],[],[],[],[],[],[],[],[] ];
      }
      function addPoint() {
        var l = tabs[0].length;
        // TODO: SoA to AoS transformation
        tabs[0].push(averages.T);
        tabs[1].push(pistonOpt.U);
        tabs[2].push(pistonOpt.PdV);
        tabs[3].push(sim.work.heat);
        tabs[4].push( (l>0) ? (sim.work.heat-tabs[3][l-1])/(averages.T-tabs[0][l-1]) : 0 );
        tabs[5].push(sim.ss.vol());
        tabs[6].push(averages.P);
        tabs[7].push(sim.step);
        tabs[8].push(sim.time);
        tabs[9].push(sim.work.thermostat);
        tabs[10].push(sim.work.barostat);
        rcount = 0;
      }
      function replot() {
        var px = $('#plottypeX option:selected').val(),
            py = $('#plottypeY option:selected').val(), i, pd =[];
        for( i = 0; i <= tabs[0].length; ++i ) {
          pd.push( [ tabs[px][i], tabs[py][i] ] );
        }
        $.plot( $('#plot'), 
          [ { 
            data: pd, 
            color : 'rgb(200,0,0)' 
          } ],
          {
            xaxis : { axisLabelUseCanvas: false, axisLabel: $('#plottypeX option:selected').text() },
            yaxis : { axisLabelUseCanvas: false, axisLabel: $('#plottypeY option:selected').text() }
          }
        );
      }
      
      function startCompute() {
        var handler, count = 0, rcount = 0;

        setInterval( function() {
          var it;
        
          for( it = 0; it < compOpt.loopSteps; ++it ) {
            sim.run(2);
            count++;
            runningAverage.addPoint();
            if( count > compOpt.samples ) {
              // TODO running average using history table
              averages = runningAverage.average();
              showP.text(Math.round(10000*averages.P)/10000);
              showT.text(Math.round(10000*averages.T)/10000);
              count = 0;
              rcount++;
              if( ploton && rcount > compOpt.equilibrate ) {
                addPoint();
                replot();
                //Q += heat();
              }
            }
          }
        }, 1000/50 );
        return function() { clearInterval(handler); }
      }

      function getRawData(tables) {
        var i,c1,c2, text = "";
        if(tables) {
          text +=  '#column1: ' + $('#plottypeX option:selected').text() + '\n';
          text +=  '#column2: ' + $('#plottypeY option:selected').text() + '\n';
          c1 =  $('#plottypeX option:selected').val();
          c2 =  $('#plottypeY option:selected').val();
          for( i = 0; i < tabs[0].length; ++i ) {
            text += tabs[c1][i] + ' ' + tabs[c2][i] + '\n';
          }
        } else {
          switch( $('#datatype option:selected').val() ) {
            case "pos" :
              text = "# " + sim.atoms.length + " atom positions\n";
              for( i = 0; i < sim.atoms.length; ++i ) {
                text += i + " " + sim.atoms[i].p.x + " " + sim.atoms[i].p.y + " " + sim.atoms[i].p.z + "\n";
              }
              break;
            case "vel" :
              text = "# " + sim.atoms.length + " atom velocities\n";
              for( i = 0; i < sim.atoms.length; ++i ) {
                text += i + " " + sim.atoms[i].v.x + " " + sim.atoms[i].v.y + " " + sim.atoms[i].v.z + "\n";
              }
              break;
          }
        }
        logp[0].value = text;
        $('#logdl').attr( 'href', 'data:text/csv;base64,' + base64enc(text) );
        $('#logbox').show(400);
      }

      // add heat to the system
      function heat() {
        var Q = 0.0, tm = 0.0, cm = new jsmd.Vector();
        for( i = 0; i < sim.atoms.length; i++ ) {
          a = sim.atoms[i];
          v2 = -a.v.len2();
          a.v.x += 0.5*(Math.random()-0.5);
          a.v.y += 0.5*(Math.random()-0.5);
          a.v.z += 0.5*(Math.random()-0.5);
          v2 += a.v.len2();
          Q += sim.types[a.t].m * v2;
  
          // obtain center of mass momentum
          cm.add( jsmd.Vector.scale(a.v,sim.types[a.t].m) );
          tm += sim.types[a.t].m;
        }

        // subtract center of mass momentum
        cm.scale(1.0/tm);
        for( i = 0; i < sim.atoms.length; i++ ) {
          sim.atoms[i].v.sub(cm);
        }

        // return average energy added per atom
        sim.work.heat += 0.5 * ( Q - tm*cm.len2() );
      }
      // remove heat from the system
      function cool() {
        var Q = 0.0;
        for( i = 0; i < sim.atoms.length; i++ ) {
          a = sim.atoms[i];
          v2 = -a.v.len2();
          a.v.zero();
          Q += sim.types[a.t].m * v2;
        }

        // tally average energy added per atom
        sim.work.heat -= 0.5*Q;
      }

      // toggle barostat
      function toggleBarostat(box) {
        sim.computeChain[4] = box.checked ? barostat : null;
      }
      // remove random atom to create a vacancy
      function addvac () { 
        sim.atoms.splice( Math.floor( Math.random() * sim.atoms.length ), 1 );
        sim.nl.update();
      }

      // moving walls (modified from computeBounce))
      function computeMovingWall(store) {
        var i, p, v, v2, 
            mwU = 0.0, dV,
            mwdss =  pistonOpt.on ? pistonOpt.sv : new jsmd.Vector(),
            mwss = jsmd.Vector.scale(mwdss,this.dt);

        // move walls (subtract twice since both opposing walls are moving in!)
        dV = this.ss.vol();
        this.ss.sub(mwss);
        this.ss.sub(mwss);
        dV -= this.ss.vol();

        // test for min max
        if( ( mwss.z > 0 && this.ss.z <= pistonOpt.min ) || 
            ( mwss.z < 0 && this.ss.z >= pistonOpt.max ) ) {
          // either 
          //   pistonOpt.sv.scale(-1) 
          // or
          pistonOpt.on = false;
          $('#piston').attr('checked','');
        }

        for( i = 0; i < this.atoms.length; ++i ) {
          p = this.atoms[i].p;
          p.sub(mwss);
          v2 = null;
          v = this.atoms[i].v;
          if( p.x < 0 ) {
            p.x = -p.x; v.x = -v.x;
            if( v2 === null ) { v2 = v.len2(); }
            v.x += 2.0 * mwdss.x;
          } else if ( p.x > this.ss.x ) {
            p.x = 2.0*this.ss.x - p.x; v.x = -v.x;
            if( v2 === null ) { v2 = v.len2(); }
            v.x -= 2.0 * mwdss.x;
          }
          if( p.y < 0 ) {
            p.y = -p.y; v.y = -v.y;
            if( v2 === null ) { v2 = v.len2(); }
            v.y += 2.0 * mwdss.y;
          } else if ( p.y > this.ss.y ) {
            p.y = 2.0*this.ss.y - p.y; v.y = -v.y;
            if( v2 === null ) { v2 = v.len2(); }
            v.y -= 2.0 * mwdss.y;
          }
          if( p.z < 0 ) {
            p.z = -p.z; v.z = -v.z;
            if( v2 === null ) { v2 = v.len2(); }
            v.z += 2.0 * mwdss.z;
          } else if ( p.z > this.ss.z ) {
            p.z = 2.0*this.ss.z - p.z; v.z = -v.z;
            if( v2 === null ) { v2 = v.len2(); }
            v.z -= 2.0 * mwdss.z;
          }
          // tally work done on the system
          if( v2 !== null ) { 
            mwU += 0.5 * sim.types[this.atoms[i].t].m * (v.len2()-v2); 
          }
        }
        pistonOpt.U += mwU;
        pistonOpt.PdV += this.P*dV;
      }

      // code for the two boundary condition animations in step1
      var bcvis = (function(){
        var c1 = $('#bc_can_period')[0].getContext('2d'), 
            c2 = $('#bc_can_reflect')[0].getContext('2d'),
            x1 = 20, y1 = 20, x2 = 20, y2 = 20,
            vx1 = 1.5, vy1 = 0.87, vx2= 1.5, vy2 = 0.87, r = 10.0, handler;

        function drawAtom(c,x,y) {
          c.beginPath();
          c.arc( x, y, r, 0, Math.PI*2.0, true);
          c.closePath();
          c.fill();
        }
        function step() {
          var i,j;

          // periodic
          c1.fillStyle = "rgba(255,255,255,1)";
          c1.fillRect(0, 0, 50, 50 );
          c1.fillStyle = "rgba(200,0,0,1)";
          for( i = -1; i <=1; ++i ) {
            for( j = -1; j <=1; ++j ) {
              drawAtom(c1,x1+50*i,y1+50*j);
            }
          }
          x1 = ( x1+vx1) % 50;
          y1 = ( y1+vy1) % 50;

          // reflecting
          c2.fillStyle = "rgba(255,255,255,1)";
          c2.fillRect(0, 0, 50, 50 );
          c2.fillStyle = "rgba(200,0,0,1)";
          drawAtom(c2,x2,y2);
          x2 += vx2;
          y2 += vy2;
          if( x2 < r ) {
            vx2 = -vx2;
            x2 = 2*r-x2;
          } else if( x2 > 50-r ) {
            vx2 = -vx2;
            x2 = 2*(50-r)-x2;
          }
          if( y2 < r ) {
            vy2 = -vy2;
            y2 = 2*r-y2;
          } else if( y2 > 50-r ) {
            vy2 = -vy2;
            y2 = 2*(50-r)-y2;
          }

          handler = setTimeout( step, 20 );
        }
        return { start: step, stop: function() { clearTimeout(handler); } }
      })();

      function updateRadios(sel) {
        $(sel).find('.radioon').addClass('radiooff').removeClass('radioon');
        $(sel).find('.radiooff').has('input:radio:checked').addClass('radioon').removeClass('radiooff');
      }

      // http://www.webtoolkit.info/javascript-base64.html
      function base64enc(input) {
        var output = "",
            keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
            chr1, chr2, chr3, enc1, enc2, enc3, enc4,
            i = 0;

        while (i < input.length) {
          chr1 = input.charCodeAt(i++);
          chr2 = input.charCodeAt(i++);
          chr3 = input.charCodeAt(i++);

          enc1 = chr1 >> 2;
          enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
          enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
          enc4 = chr3 & 63;

          if (isNaN(chr2)) {
                          enc3 = enc4 = 64;
          } else if (isNaN(chr3)) {
                          enc4 = 64;
          }
          output += keyStr.charAt(enc1) + keyStr.charAt(enc2) +
                    keyStr.charAt(enc3) + keyStr.charAt(enc4);
        }
        return output;
      }
    </script>
  </body>
</html>
