<!DOCTYPE HTML>
<html lang="en">
  <head>
    <title>jsMD - MatSE 401</title>
    <meta charset="utf-8">
    <script type="text/javascript" src="../render3d.js"></script>
    <script type="text/javascript" src="../vector3d.js"></script>
    <script type="text/javascript" src="../linkcell3d.js"></script>
    <script type="text/javascript" src="../neighborlist3d.js"></script>
    <script type="text/javascript" src="../jsmd.js"></script>
    <script type="text/javascript" src="../lib/Three.js"></script>
    <script type="text/javascript" src="../lib/jquery.pack.js"></script>
    <script src="../lib/MathJax/MathJax.js">
      MathJax.Hub.Config({
        extensions: ["tex2jax.js","TeX/bbox.js"],
        imageFont: null,
        //menuSettings: { zoom: 'Hover' },
        jax: ["input/TeX","output/HTML-CSS"],
        tex2jax: {inlineMath: [["$","$"],["\\(","\\)"]]}
      });
    </script>
    <style>
      div.box { 
        border: 1px solid gray; margin: 5px; padding: 5px;
        position: relative;
        -moz-box-shadow: 5px 5px 5px #ccc;
        -webkit-box-shadow: 5px 5px 5px #ccc;
        box-shadow: 5px 5px 5px #ccc;
      }
      .right { margin-left: 510px !important }

      div.green { background-color: #aaffaa }
      div.blue { background-color: #aaaaff }
      div.optional { 
        display: none; 
        position: relative;
        padding-top: 5px; 
        margin-top: 5px; 
        border-top: 1px dashed gray; 
      }
      div.helptext { 
        display: none;
        padding: 5px;
        font-size: 90%;
      }
      a.wp { 
        color: black;
        text-decoration: none;
      }

      div.vertdrag {
        padding-top: 4px;
        width: 30%;
        height: 4px;
        background-color: #777777;
        margin-left: auto;
        margin-right: auto;
        cursor: s-resize;
      }

      .width100 {
        width: 100%;
        -moz-box-sizing: border-box;
        -webkit-box-sizing: border-box;
        box-sizing: border-box;
      }
      
      #step1,#step1b,#step2,#step3 {
        border: 1px dotted blue;
        background-color: #eeeeee;
        padding: 0.5em;
      }
      h1 { font-family: sans; }
      #step1b { display: none; border-color: red; margin-bottom: 5px; }
      #matrixbox { display: none }
      #matrixcontainer>table>tbody>tr>td {
        border: 1px solid black;
        cursor: pointer;
        width: 3em;
        height: 3em;
        text-align: center;
        -webkit-user-select: none;
        -moz-user-select: none;
        -o-user-select: none;
        user-select: none;
      }
      #step2 { display: none }
      #step3 { display: none }
  
      /*.radiooff, .radiooff p { color: gray; }*/
      div.radioon { border: 1px solid black }
      .radiooff { opacity: 0.35 }
    </style>
  </head>
  <body>
    <!-- Step 1: choose system geometry -->
    <div id="step1">
      <h1>Sample geometry</h1>
      <p>Select a sample geometry and boundary conditions.</p>
      <div style="width: 48%; float: left">
        <div class="box radioon">
          <input value="fcc" type="radio" name="sample" onchange="updateRadios('#step1')" checked id="sam_fcc"/> 
          <label for="sam_fcc"><b>Crystalline solid</b> (face centered cubic lattice)</label></br>
          $d=$ <input type="number" value="8" id="crboxsize"/> (crystal size $d\times d\times d$ unit cells )
        </div>
        <div class="box radiooff">
          <input value="nano" type="radio" name="sample" onchange="updateRadios('#step1')" id="sam_nano"/> 
          <label for="sam_nano"><b>Nano particle</b></label></br>
          $r=$ <input type="number" value="3" id="npradius"/> &Aring; (radius)
        </div>
        <div class="box radiooff">
          <input value="gas" type="radio" name="sample" onchange="updateRadios('#step1')" id="sam_gas"/> 
          <label for="sam_gas"><b>Gas</b></label></br>
          $N=$ <input type="number" value="1000" id="sgnum"/> (number of atoms)<br/>
          $T=$ <input type="number" value="100.0" id="sgtemp"/> K (temperature)<br/>
          $L=$ <input type="number" value="40.0" id="sglen"/> &Aring; (box size, $V=L^3$)<br/>
          <div class="optional">
            <input id="sglim" type="checkbox" checked>
            <label for="sglim">enforce minimum separation distance for initial state</label><br/>
            r<sub>min</sub>=<input id="sgminr" type="number" value="1.4" step="0.1"/> Ang<br/>
            <div class="helptext">
              The gas atoms are placed at random positions in the simulation box. 
              If an interaction potential is used, a small fraction of neighboring 
              atoms may be very close and thus in the repulsive regime of the 
              potential. These atoms will repell eachother vigorously and accellerate 
              very fast. This is undesired and can be avoided by checking this option.
            </div>
          </div>
        </div>
      </div>
      <div style="width: 48%; float: right">
          <div class="box radioon">
          <input value="period" type="radio" name="boundary" onchange="updateRadios('#step1')" checked id="bc_period"/> 
          <label for="bc_period"><b>Periodic boundaries</b></label></br>
          <span style="color: red">Volume changing <i>piston</i> is <b>not available</b> in this mode!</span>
          <canvas id="bc_can_period" style="float: right; border: 1px solid black" width="50" height="50"></canvas>
          <br style="clear: both"/>
      </div>
        <div class="box radiooff">
          <input value="reflect" type="radio" name="boundary" onchange="updateRadios('#step1')" id="bc_reflect"/> 
          <label for="bc_reflect"><b>Reflecting boundaries</b></label></br>
          <canvas id="bc_can_reflect" style="float: right; border: 1px solid black" width="50" height="50"></canvas>
          <br style="clear: both"/>
        </div>
      </div>
      <br style="clear: both"/>
      <button onclick="gostep(1,2)" onmouseover="$('#step1').find('.optional').stop(true)">Next</button>
    </div>               

    <div id="step1b">
      <b>Selected sample is too dense to enforce the chosen minimum distance!</b><br/>
      Your options are:
      <ul>
        <li><a href="#" onclick="$('#step1b').hide(400); gostep(1,2)">Retry</a> (may help in bordeline cases)</li> 
        <li><a href="#" onclick="$('#step1b').hide(400); $('#sglim').attr('checked',''); gostep(1,2)">Retry without enforcing minimum distance</a></li>
        <li><a href="#" onclick="$('#step1b').hide(400); gostep(2,1)">Go back</a> and retry with smaller r<sub>min</sub></li>
      </li>
      As a workaround you can also attempt to continue and relax the system to a low temperature (press <i>remove heat</i> repeatedly) and then use a thermostat to reach the desired sample temperature.<br/>
      <button onclick="$('#step1b').hide(400)">Dismiss</button>
    </div>

    <!-- Step 2: choose interaction potential -->
    <div id="step2">
      <h1>Atomic interactions</h1>
      <p>Select an interaction potential and its parameters.</p>
      <div style="width: 38%; float: right">
        <div class="box">
          <b>Number of chemical species in the simulation</b><br/>
          <select id="numel" onchange="updateNumEl()"/>
            <option value="1">1</option>
            <option value="2">2</option>
            <option value="3">3</option>
            <option value="4">4</option>
          </select>
          <ol id="numellist">
          </ol>
          <div id="numeltemplate" style="display: none">
            <div style="display: inline-block; width: 1em; height: 1em; border: 1px solid black"></div> name: <input type="text" title="descriptive name"/> , 
            <span style="white-space: nowrap">m<sub></sub>=<input title="atomic mass" type="number" value="1"> <a class="wp" href="Atomic_mass_unit">amu</a></span>
          </div>
        </div>
        <div class="box" id="matrixbox">
          <b>Pair interaction matrix</b>
          <div id="matrixcontainer"></div>
          <div class="helptext">
            The interaction matrix determines which potential to use between each pair of atoms of all possible combinations of chemical species. There are as many rows and columns as there are species, and each cell in the matrix contains the interaction of type <i>row</i> with type <i>column</i>. Click on a cell and select the potential potential and its parameters on the left, until all cells appear green.
          </div>
        </div>
      </div>
      <div style="width: 58%; float: left" id="potentialform">
        <div class="box radioon">
          <input value="none" type="radio" name="potential" onchange="updateRadios('#step2')" checked id="pot_none"/> 
          <label for="pot_none"><b>No interaction</b> (ideal gas)</label></br>
        </div>
        <div class="box radiooff">
          <input value="lj" type="radio" name="potential" onchange="updateRadios('#step2')" id="pot_lj"/>
          <label for="pot_lj"><b>Lennard-Jones</b> pair potential</label></br>
          <p>\[ 
              V(r)=4 \varepsilon \left[ \left( \frac {\sigma} {r} \right)^{12} - \left( \frac {\sigma} {r} \right)^6 \right]
          \]</p>
          $\varepsilon=$ <input type="number" value="50.0" id="ljepsilon"/> K (binding energy)<br/>
          $\sigma=$ <input type="number" value="1.295" id="ljsigma"/> &Aring; (length scale, $2^{\frac16}\sigma=r_m$ is equilibrium dimer separation distance)<br/>
          $r_{cut}=$ <input type="number" value="3.5" id="ljrcut"/> &Aring; (all atomic interactions beyond $r_{cut}$ are ignored. recommended: $r_{cut}\approx2.5\sigma$)
        </div>
      </div>
      <br style="clear: both"/>
      <button onclick="gostep(2,1)">Back</button>
      <button onclick="gostep(2,3)">Next</button>
    </div>

    <!-- Step 3: run stuff -->
    <div id="step3">
      <h1>Simulation</h1>
      <div class="box" style="height: 600px" id="simcan"></div>
      <div style="width: 500px; float: left">
        <div class="box blue">
          <div><i><a class="wp" href="Temperature">T = </a><span id="showT"></span></i> <a class="wp" href="Kelvin">K</a></div>
          <div><i><a class="wp" href="Pressure">P = </a><span id="showP"></span></i> <a class="wp" href="Pascal_(unit)">MPa</a></div>
        </div>

        <div class="box">
          <button onclick="heat()" title="add heat and remove center of mass momentum">Add heat</button>
          <button onclick="cool()" title="set all atom velocities to zero">Remove heat</button>
          <button onclick="addvac()" title="remove one random atom">Add vacancy</button><br/>
        </div>

        <div id="pistonbox" class="box">
          <input id="piston" type="checkbox" onclick="pistonOpt.on=this.checked">
          <label for="piston">Move piston</label><br/>
          max<sub>z</sub>=<input type="number" value="80.0" onchange="pistonOpt.max=this.value"/> &Aring;,
          min<sub>z</sub>=<input type="number" value="20.0" onchange="pistonOpt.min=this.value"/> &Aring; <br/>
          v<sub>z</sub>=<input id="pistonvz" type="number" value="0.2" step="0.1" onchange="pistonOpt.sv.z=this.value"  /> &Aring;/fs
          <button onclick="pistonOpt.sv.z *=-1; $('#pistonvz').val(pistonOpt.sv.z)">Reverse</button>
          <div class="helptext">
            The <i>piston</i> is implemented by moving the two box walls perpendicular to the z-axis inward with a velocity of v<sub>z</sub> (negative v<sub>z</sub> move the walls apart). The wall is assumed to have infinite mass and reflected particles will exhibit a momentum transfer, adding 2v<sub>z</sub> to their velocity z-component.
          </div>
        </div>
<!--
        <div class="box">
          <input id="ramp" type="checkbox" onclick="ramp(this)">
          <label for="ramp">Auto ramp-up</label><br/>
          Plot <select id="plottype">
            <option value="0">Temperatue vs. added heat T(Q)</option>
            <option value="1">Heatcapacity vs. Temperature c(T)</option>
            <option value="2">Volume vs. Temperature V(T)</option>
            <option value="3">Presure vs. Temperature P(T)</option>
          </select>
        </div>
-->
        <div class="box green">
          <input id="gatheron" type="checkbox" onclick="gatheron=this.checked">
          <label for="gatheron">Gather data</label>
          <input id="ploton" type="checkbox" onclick="ploton=this.checked" checked>
          <label for="ploton">Autorefresh plot</label>
          <button onclick="addPoint(); replot()">Plot</button>
          <button onclick="clearTabs(); replot()">Clear</button>
          <br/>
          Plot 
          <select id="plottypeY" onchange="replot()">
            <option value="0" selected>Temperature [K]</option>
            <option value="6">Pressure [MPa]</option>
            <option value="5">Volume [Ang&sup3;]</option>
            <option value="1">Work performed by piston (atomic) [eV]</option>
            <option value="2">Work performed by piston (p dV) [eV]</option>
            <option value="14">Total kinetic energy [eV]</option>
            <!--<option value="4">Heatcapacity</option>-->
            <option value="3">Added heat [eV]</option>
            <option value="9">Heat input by thermostat [eV]</option>
            <option value="10">Work performed by barostat [eV]</option>
            <option value="11">Thermostat settemperature [K]</option>
            <option value="12">Barostat setpressure [MPa]</option>
            <option value="7">Simulation step</option>
            <option value="8">Simulation time [fs]</option>
            <option value="13">Number of atoms</option>
          </select>
          vs. 
          <select id="plottypeX" onchange="replot()">
            <option value="0">Temperature [K]</option>
            <option value="6" selected>Pressure [MPa]</option>
            <option value="5">Volume [Ang&sup3;]</option>
            <option value="1">Work performed by piston (atomic) [eV]</option>
            <option value="2">Work performed by piston (p dV) [eV]</option>
            <option value="14">Total kinetic energy [eV]</option>
            <!--<option value="4">Heatcapacity</option>-->
            <option value="3">Added heat [eV]</option>
            <option value="9">Heat input by thermostat [eV]</option>
            <option value="10">Work performed by barostat [eV]</option>
            <option value="11">Thermostat settemperature [K]</option>
            <option value="12">Barostat setpressure [MPa]</option>
            <option value="7">Simulation step</option>
            <option value="8">Simulation time [fs]</option>
            <option value="13">Number of atoms</option>
          </select>
          <button onclick="getRawData(true)">Get data</button>
        </div>

        <div class="box">
          <input id="baro" type="checkbox" onclick="sim.computeChain[4] = this.checked ? barostat : null">
          <label for="baro">Activate barostat (affecting <span id="baroaffect"></span>)</label><br/>
          P<sub>0</sub>=<input type="number" id="barop0" value="0.0" 
                               onchange="baropt.P0=parseFloat(this.value)/jsmd.constants.MPa"/> MPa,
          &tau;=<input type="number" value="100.0" onchange="baropt.tau=parseFloat(this.value)"/> fs
          <div class="optional">
            <input id="baroramp" type="checkbox" 
                   onclick="baropt.ramp=this.checked; $('#barop0').attr('disabled', baropt.ramp);">
            <label for="baroramp">ramp barostat setpressure</label><br/>
            $\frac{dP_0}{dt}$=<input type="number" value="0.01" step="0.01" 
                                           onchange="baropt.dP0dt=parseFloat(this.value)/jsmd.constants.MPa"/> MPa/fs
          </div>
          <div class="helptext">
            A barostat controls the <i>pressure</i> in the simulation cell. Pressure is lowered by expanding the cell and increased by shrinking the cell.
            jsMD implements a <a href="http://www.pages.drexel.edu/~cfa22/msim/node37.html">Berendsen barostat</a>.
          </div>
        </div>

        <div class="box">
          <input id="therm" type="checkbox" onclick="sim.computeChain[5] = this.checked ? thermostat : null">
          <label for="therm">Activate thermostat</label><br/>
          T<sub>0</sub>=<input type="number" id="thermt0" value="10" step="1" onchange="thermopt.T0=parseFloat(this.value)*jsmd.constants.kB"/> K,
          &tau;=<input type="number" value="0.1" step="0.1" onchange="thermopt.tau=parseFloat(this.value)"/> fs
          <div class="optional">
            <input id="thermramp" type="checkbox" 
                   onclick="thermopt.ramp=this.checked; $('#thermt0').attr('disabled', thermopt.ramp);">
            <label for="thermramp">ramp thermostat settemperature</label><br/>
            $\frac{dT_0}{dt}$=<input type="number" value="0.5" step="0.1" onchange="thermopt.dT0dt=parseFloat(this.value)*jsmd.constants.kB"/> K/fs
          </div>
          <div class="helptext">
            A thermostat controls the <i>temperature</i> in the simulation cell. jsMD implements a <a href="http://en.wikipedia.org/wiki/Berendsen_thermostat">Berendsen thermostat</a> that regulates temperature through simple velocity rescaling.
          </div>
        </div>

        <div class="box green">
          Get raw data for
          <select id="datatype">
            <option value="vel">Atom velocities</option>
            <option value="pos">Atom positions</option>
          </select>
          <button onclick="getRawData(false)">Go</button>
        </div>
      </div>
      <div class="box right" id="logbox" style="display: none; position: relative">
        <textarea id="log" style="height: 300px" class="width100" wrap="off"></textarea>
        <button onclick="$('#logbox').hide(400)">Ok</button>
        <a style="position: absolute; right:1em" id="logdl" target="data" download="data.txt" href="">Download data..</a>
      </div>
      <div id="plotbox" class="box right">
        <div id="plot" style="width: 100%; height: 450px;"></div>
        <div class="vertdrag" id="plotresize"></div>
      </div>
      <br style="clear: both"/>
      <button onclick="gostep(3,2)">Back</button>
    </div>

    <script type="text/javascript">

      var jsmd = initJSMD(3),
          ss, sv,
          sc = $('#simcan'),
          sim, force,
          t, c = 0, a, p = new jsmd.Vector, x, y, i,
          matrix = { ci:0, cj:0, form:[] },
          elements = {
            colorHTML : [ '#ff0000', '#00ff00', '#0000ff', '#ff00ff' ],
            color3d : [ {r:1,g:0,b:0},{r:0,g:1,b:0},{r:0,g:0,b:1},{r:1,g:0,b:1}  ],
            li : []
          },
          averages = {}, rup = false,
          logp = $('#log'),
          showT = $('#showT'),
          showP = $('#showP'),
          render3d, stopAnim, stopCompute, ploton = true, gatheron = false,
          compOpt = { samples: 40, equilibrate: 20, loopSteps: 1 }, 
          pistonOpt = { max: 80, min: 20.0, sv: new jsmd.Vector(0,0,0.2), on: false, U: 0.0, PdV: 0.0 },
          reqAnim = window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame,
          tabs;

      // initialization code
      $(function() {
        // make sure the box highlighting corresponds to the radio button state (some browseres restore forms)
        updateRadios('#step1');

        // prepare UI for element list
        var i, div;
        for( i = 0; i< 4; ++i ) {
          div = $('<li></li>').append( $('#numeltemplate').children().clone() ).appendTo( $('#numellist') );
          div.find('input').eq(0).attr('id','numelname_'+i);
          div.find('div').css('backgroundColor',elements.colorHTML[i]);
          div.find('input').eq(1).attr('id','numelmass_'+i);
          elements.li[i] = div;
        }
        updateNumEl();

        // duplicate the onchange hander into click handler for input[type=number] elements
        // workaround for http://code.google.com/p/chromium/issues/detail?id=51836
        $('input[type=number]').each( function(i,e) { if( e.onclick == null ) { e.onclick=e.onchange; } } );
        
        // open all wp links in external window
        $('a.wp').each( function(i,e) { 
          $(e).attr( { 
            target: 'wp', 
            href: 'http://en.wikipedia.org/wiki/'+$(e).attr('href') 
          } ); 
        } );

        // wire-up all help boxes
        $('div.helptext').each( function(i,e) {
          $(e).parent().append( 
            $('<img src="gtk-info.svg">')
              .css( { 
                position: 'absolute', 
                top: '3px', right: '3px',
                cursor: 'pointer'
              } )
              .attr( 'title', 'Toggle help' )
              .toggle( function() { $(e).show() }, function() { $(e).hide() } ) 
          );
        } );

        // start animations for boundary condition selection
        bcvis.start();
        
        // initialize plotting data tables
        clearTabs();

        // make plot resizable
        var oy;
        function doResizing(e) {
          if( e.clientY != oy ) {
            var h = $('#plot').height();
            $('#plot').height(h+e.clientY-oy);
            oy = e.clientY;
          }
        }
        function doneResizing(e) {
          $(document).unbind( 'mousemove', doResizing ); 
          $(document).unbind( 'mouseup', doneResizing ); 
          replot(); 
        } 
        $('#plotresize')
          .mousedown( function(e) 
          { 
            oy = e.clientY; 
            $(document).bind( 'mousemove', doResizing ).bind('mouseup', doneResizing ); 
          } );

        // add logic to show .optional on hover
        $('.optional').each( function(i,e) {
          $(e).parent()
            .mouseenter( function(){ $(e).stop(true,true).delay(500).slideDown(400); } )
            .mouseleave( function(){ $(e).stop(true,true).delay(500).slideUp(400); } )
        } );
      });

      function gostep(n1,n2) {
        var x,y,z,n,p = new jsmd.Vector(),
            fcc = [[0,0,0],[1,1,0],[1,0,1],[0,1,1]];
        $('#step'+n1).hide(400);
        switch( n1 ) {
          case 1: 
            // construct simulation object 
            switch( $('input:radio[name=sample]:checked').val() ) {
              case 'fcc' : 
                ss = Math.round($('#crboxsize').val()); 
                sv = new jsmd.Vector(ss,ss,ss);
                sim = new jsmd.Simulation(sv);

                // insert atoms
                for( x = 0; x < ss/2; ++x ) {
                  for( y = 0; y < ss/2; ++y ) {
                    for( z = 0; z < ss/2; ++z ) {
                      for( n = 0; n < 4; ++n ) {
                        p.x = (2*x+fcc[n][0])+0.5;
                        p.y = (2*y+fcc[n][1])+0.5;
                        p.z = (2*z+fcc[n][2])+0.5;
                        a = new jsmd.Atom(p);
                        a.p.wrap(sv);
                        a.v.x = 0.5*(Math.random()-0.5);
                        a.v.y = 0.5*(Math.random()-0.5);
                        a.v.z = 0.5*(Math.random()-0.5);
                        a.t = n;
                        sim.atoms.push(a);
                      }   
                    }
                  }
                }
                break;
              case 'nano' :
                var r = parseFloat($('#npradius').val()), r2=r*r, half;
                ss = r*8.0; 
                sv = new jsmd.Vector(ss,ss,ss);
                half = jsmd.Vector.scale(sv,0.5);
                sim = new jsmd.Simulation(sv);
                // insert atoms
                for( x = -ss/4; x < ss/4; ++x ) {
                  for( y = -ss/4; y < ss/4; ++y ) {
                    for( z = -ss/4; z < ss/4; ++z ) {
                      for( n = 0; n < 4; ++n ) {
                        p.x = (2*x+fcc[n][0])+0.5;
                        p.y = (2*y+fcc[n][1])+0.5;
                        p.z = (2*z+fcc[n][2])+0.5;
                        if( p.len2() <= r2 ) {
                          p.add(half)
                          a = new jsmd.Atom(p);
                          a.p.wrap(sv);
                          a.v.x = 0.5*(Math.random()-0.5);
                          a.v.y = 0.5*(Math.random()-0.5);
                          a.v.z = 0.5*(Math.random()-0.5);
                          sim.atoms.push(a);
                        }
                      }   
                    }
                  }
                }
                break;
              case 'gas' :
                var num = parseInt($('#sgnum').val()),
                    temp = parseFloat($('#sgtemp').val()) * jsmd.constants.kB,
                    rmin = parseFloat($('#sgminr').val()),
                    limit = $('#sglim').attr('checked'),
                    i,w,x1,x2,v2 = 0.0,gr=[];
                ss = parseFloat($('#sglen').val());
                sv = new jsmd.Vector(ss,ss,ss);
                sim = new jsmd.Simulation(sv);

                // create and position atoms
                for( n = 0; n < num; ++n ) {
                  // create atom at random position
                  a = new jsmd.Atom( jsmd.Vector.random(sv) );
                  a.t = n % 4;
                  sim.atoms.push(a);
                }

                // make sure none are closer than rmin
                if( limit ) {
                  sim.setCutOff(rmin,0.0);
                  var dirty, attempt = 1;
                  do {
                    if( attempt > 40 ) {
                      $('#step1b').show(400);
                      break;
                    }
                    sim.nl.update();
                    dirty = false;
                    // reposition all atoms that have a non-empty neighbor list (=too close)
                    for( n = 0; n < num; ++n ) {
                      if( sim.nl.data[n].length > 0 ) {
                        sim.atoms[n].p.random(sv);
                        dirty = true;
                      }
                    }
                    attempt++;
                  } while(dirty);
                  //$('#step1b').hide(400);
                }

                // assign gaussian distributed velocities
                for( n = 0; n < num; ++n ) {
                  // fill gaussian random number reservoir
                  if( n%2 == 0 ) {
                    for( i = 0; i<3; ++i ) {
                      do {
                        x1 = 2.0 * Math.random() - 1.0;
                        x2 = 2.0 * Math.random() - 1.0;
                        w = x1 * x1 + x2 * x2;
                      } while ( w >= 1.0 );

                      // TODO: consider mass in a two atom gas!
                      w = Math.sqrt( (-2.0 * Math.log( w ) ) / w ); 
                      gr[2*i] = x1 * w;
                      gr[2*i+1] = x2 * w;
                    }
                  }
                     
                  // create atom at random position, with gaussian velocity distribution
                  a = sim.atoms[n];
                  a.v.x = gr[(n%2)*3];
                  a.v.y = gr[(n%2)*3+1];
                  a.v.z = gr[(n%2)*3+2];
                  v2 += a.v.len2() * 1.0; // TODO: mass assumed to be 1.0
                }

                // rescale to desired temperature
                w = Math.sqrt( num * 3.0 * temp / v2  );
                for( n = 0; n < num; ++n ) {
                  sim.atoms[n].v.scale(w);
                }
                break;
            }

            // add entry for heat influx/outflux
            sim.work.heat = 0.0;

            // set compute chain
            sim.computeChain = [ 
              jsmd.compute.verlet1,    // [0]
              // PBC or reflect
              ($('input:radio[name=boundary]:checked').val() == 'period') ? jsmd.compute.wrap : computeMovingWall, // [1]
              null               ,     // [2] computeForces
              jsmd.compute.verlet2,    // [3]
              null,                    // [4]
              null                     // [5]
            ];

            // delete existing visualization
            $('#simcan').empty();

            // stop little animations
            bcvis.stop();

            // show/hide pistion box depending on BC
            if( $('input:radio[name=boundary]:checked').val() == 'period' ) {
              $('#pistonbox').hide();
              pistonOpt.on=false;
              barostat = jsmd.compute.berendsenP( baropt );
              $('#baroaffect').text('volume');
            } else {
              $('#pistonbox').show();
              pistonOpt.on=$('#piston')[0].checked;
              barostat = jsmd.compute.berendsenP2( baropt );
              $('#baroaffect').text('temperature');
            }
            break;
          case 2:
            $('#step1b').hide(400);
            
            // save current formstate into matrix.form
            if( !matrix.form[matrix.ci] ) { matrix.form[matrix.ci] = [] }
            matrix.form[matrix.ci][matrix.cj] = saveForm('#potentialform');

            // default is no force calculation, if even one potential is used this will be overridden
            sim.computeChain[2] = null;

            // set elements
            var i, j, numel = parseInt($('#numel option:selected').val());
            for( i = 0; i < numel; i++ ) { 
              t = new jsmd.AtomType();
              t.r = parseFloat($('#numelmass_'+i).val());
              t.name = $('#numelname_'+i).val();
              t.color3d = elements.color3d[i];
              sim.types[i] = t;
            }
            
            // initialize render3d (container must not be hidden!)
            $('#step3').css( { display: "block", visibility: "hidden" } )
            render3d = initRender3D( sim, $('#simcan')[0] );
            $('#step3').css( { display: "none", visibility: "visible" } )
      
            // loop over interaction settings
            var rcut, rcutmax = 0.0;
            for( i = 0; i < numel; ++i ) {
              for( j = i; j < numel; ++j ) {

                // test if input exists
                // potential 'none'
                if( !matrix.form[i] || !matrix.form[i][j] || matrix.form[i][j].pot_none ) {
                  // empty potential, don't do anything here
                  continue;
                } 

                if( matrix.form[i][j].pot_lj ) {
                  // get cut off
                  rcut = parseFloat(matrix.form[i][j].ljrcut);
                  if( rcut > rcutmax ) {
                    rcutmax = rcut;
                  }
                  
                  // tabulate the potential with a spacing of 0.01 and the selected cut-off
                  force = jsmd.potential.tabulated( 
                    jsmd.potential.lennardJones( 
                      parseFloat(matrix.form[i][j].ljsigma), 
                      parseFloat(matrix.form[i][j].ljepsilon) ), 0.01, rcut 
                  );

                  // set interaction matrix (1x1)
                  sim.computeChain[2] = jsmd.compute.forces;
                }

                // insert force into interaction matrix
                sim.setInteraction( [i,j], force );
              }
            }

            // use largest cutoff for the neighborlist
            sim.setCutOff(rcutmax,0.5);
            sim.nl.update();

            // misc
            sim.drag = 1.0;
            sim.renderChain = [ ];
            break;
          case 3:
            stopAnim();
            stopCompute();
            break;
        }
        switch( n2 ) {
          case 1:
            bcvis.start();
            break;
          case 2: 
            updateRadios('#step2');
            break
          case 3: 
            stopAnim = startAnim();
            stopCompute = startCompute();
            break;
        }
        $('#step'+n2).show(400);
      }


      // w and w/o barostat
      var baropt = { P0: 0.0, tau: 100.0, ramp: false, dP0dt: 0.01 },
          barostat,
          thermopt = { T0: 10.0, tau: 0.1, ramp: false, dT0dt: 0.5 },
          thermostat = jsmd.compute.thermostat( thermopt );

      function startAnim() {
        var keepRunning, handler;
        function frame() {
          render3d();
          if( keepRunning ) { reqAnim(frame); }
        }
        if( reqAnim ) {
          keepRunning = true;
          frame();
        } else {
          keepRunning = false;
          handler = setInterval( render3d, 50 );
        }

        // return a function to stop the animation
        return function() { 
          if( keepRunning  ) { 
            keepRunning = false;
          } else {
            clearInterval( handler );
          }
        }
      }

      var runningAverage = {
        buffer : [],
        index : 0,
        _num : 20,
        addPoint: function() {
          this.buffer[this.index++] = { P: sim.P, T: sim.T }
          if( this.index >= this._num ) {
            this.index = 0;
          }
        },
        average: function() {
          var i, a = { P: 0.0, T: 0.0 }, c = 0;
          for( i = 0; i < this.buffer.length && i < this._num; ++i ) {
            a.P += this.buffer[i].P;
            a.T += this.buffer[i].T;
            c++;
          }
          a.P /= c;
          a.T /= c;
          return a;
        },
        setNum: function(num) {
          this.buffer = [];
          this.index = 0;
          this._num = num;
          this.addPoint();
        }
      }
      function clearTabs() {
        // clear gathered data
        tabs = [ [],[],[],[],[],[],[],[],[],[],[],[],[],[],[] ];

        // reset work counters for thermo, barostat, and add heat
        if( sim ) {
          sim.work.thermostat = 0.0;
          sim.work.barostat = 0.0;
          sim.work.heat = 0.0;
        }
      }
      function addPoint() {
        var l = tabs[0].length;
        // TODO: SoA to AoS transformation
        tabs[0].push( averages.T / jsmd.constants.kB );
        tabs[1].push( pistonOpt.U * jsmd.constants.eV );
        tabs[2].push( pistonOpt.PdV * jsmd.constants.eV );
        tabs[3].push( sim.work.heat * jsmd.constants.eV );
        tabs[4].push( (l>0) ? (sim.work.heat-tabs[3][l-1])/(averages.T-tabs[0][l-1]) : 0 );
        tabs[5].push(sim.ss.vol());
        tabs[6].push( averages.P * jsmd.constants.MPa );
        tabs[7].push(sim.step);
        tabs[8].push(sim.time);
        tabs[9].push( sim.work.thermostat * jsmd.constants.eV );
        tabs[10].push( sim.work.barostat * jsmd.constants.eV );
        tabs[11].push( thermopt.T0 / jsmd.constants.kB );
        tabs[12].push( baropt.P0 * jsmd.constants.MPa );
        tabs[13].push( sim.atoms.length );
        tabs[14].push( sim.Ekin * jsmd.constants.eV );
        rcount = 0;
      }
      function replot() {
        var px = $('#plottypeX option:selected').val(),
            py = $('#plottypeY option:selected').val(), i, pd =[];
        for( i = 0; i <= tabs[0].length; ++i ) {
          pd.push( [ tabs[px][i], tabs[py][i] ] );
        }
        $.plot( $('#plot'), 
          [ { 
            data: pd, 
            color : 'rgb(200,0,0)' 
          } ],
          {
            xaxis : { axisLabelUseCanvas: false, axisLabel: $('#plottypeX option:selected').text() },
            yaxis : { axisLabelUseCanvas: false, axisLabel: $('#plottypeY option:selected').text() }
          }
        );
      }
      
      function startCompute() {
        var handler, count = 0, rcount = 0;

        setInterval( function() {
          var it;
        
          for( it = 0; it < compOpt.loopSteps; ++it ) {
            sim.run(2);
            count++;
            runningAverage.addPoint();
            if( count > compOpt.samples ) {
              // update thermo and barostat settings
              if( thermopt.ramp ) { $('#thermt0').val( thermopt.T0 / jsmd.constants.kB ); }
              if( baropt.ramp ) { $('#barop0').val( baropt.P0 * jsmd.constants.MPa ); }

              // get running average using history table
              averages = runningAverage.average();
              showP.text(Math.round( 10000 * ( averages.P * jsmd.constants.MPa ) )/10000);
              showT.text(Math.round( 10000 * ( averages.T / jsmd.constants.kB ) )/10000);
              count = 0;
              rcount++;
              if( gatheron && rcount > compOpt.equilibrate ) {
                addPoint();
                if( ploton ) { replot(); }
              }
            }
          }
        }, 1000/50 );
        return function() { clearInterval(handler); }
      }

      function getRawData(tables) {
        var i,c1,c2, text = "";
        if(tables) {
          text +=  '#column1: ' + $('#plottypeX option:selected').text() + '\n';
          text +=  '#column2: ' + $('#plottypeY option:selected').text() + '\n';
          c1 =  $('#plottypeX option:selected').val();
          c2 =  $('#plottypeY option:selected').val();
          for( i = 0; i < tabs[0].length; ++i ) {
            text += tabs[c1][i] + ' ' + tabs[c2][i] + '\n';
          }
        } else {
          switch( $('#datatype option:selected').val() ) {
            case "pos" :
              text = "# " + sim.atoms.length + " atom positions\n";
              for( i = 0; i < sim.atoms.length; ++i ) {
                text += i + " " + sim.atoms[i].p.x + " " + sim.atoms[i].p.y + " " + sim.atoms[i].p.z + "\n";
              }
              break;
            case "vel" :
              text = "# " + sim.atoms.length + " atom velocities\n";
              for( i = 0; i < sim.atoms.length; ++i ) {
                text += i + " " + sim.atoms[i].v.x + " " + sim.atoms[i].v.y + " " + sim.atoms[i].v.z + "\n";
              }
              break;
          }
        }
        logp[0].value = text;
        $('#logdl').attr( 'href', 'data:text/csv;base64,' + base64enc(text) );
        $('#logbox').show(400);
      }

      // add heat to the system
      function heat() {
        var Q = 0.0, tm = 0.0, cm = new jsmd.Vector();
        for( i = 0; i < sim.atoms.length; i++ ) {
          a = sim.atoms[i];
          v2 = -a.v.len2();
          a.v.x += 0.5*(Math.random()-0.5);
          a.v.y += 0.5*(Math.random()-0.5);
          a.v.z += 0.5*(Math.random()-0.5);
          v2 += a.v.len2();
          Q += sim.types[a.t].m * v2;
  
          // obtain center of mass momentum
          cm.add( jsmd.Vector.scale(a.v,sim.types[a.t].m) );
          tm += sim.types[a.t].m;
        }

        // subtract center of mass momentum
        cm.scale(1.0/tm);
        for( i = 0; i < sim.atoms.length; i++ ) {
          sim.atoms[i].v.sub(cm);
        }

        // return average energy added per atom
        sim.work.heat += 0.5 * ( Q - tm*cm.len2() );
      }
      // remove heat from the system
      function cool() {
        var Q = 0.0;
        for( i = 0; i < sim.atoms.length; i++ ) {
          a = sim.atoms[i];
          v2 = -a.v.len2();
          a.v.zero();
          Q += sim.types[a.t].m * v2;
        }

        // tally average energy added per atom
        sim.work.heat -= 0.5*Q;
      }

      // toggle barostat
      function toggleBarostat(box) {
        sim.computeChain[4] = box.checked ? barostat : null;
      }
      // remove random atom to create a vacancy
      function addvac () { 
        sim.atoms.splice( Math.floor( Math.random() * sim.atoms.length ), 1 );
        sim.nl.update();
      }

      // moving walls (modified from computeBounce))
      function computeMovingWall(store) {
        var i, p, v, v2, 
            mwU = 0.0, dV,
            mwdss =  pistonOpt.on ? pistonOpt.sv : new jsmd.Vector(),
            mwss = jsmd.Vector.scale(mwdss,this.dt);

        // move walls (subtract twice since both opposing walls are moving in!)
        dV = this.ss.vol();
        this.ss.sub(mwss);
        this.ss.sub(mwss);
        dV -= this.ss.vol();

        // test for min max
        if( ( mwss.z > 0 && this.ss.z <= pistonOpt.min ) || 
            ( mwss.z < 0 && this.ss.z >= pistonOpt.max ) ) {
          // either 
          //   pistonOpt.sv.scale(-1) 
          // or
          pistonOpt.on = false;
          $('#piston').attr('checked','');
        }

        for( i = 0; i < this.atoms.length; ++i ) {
          p = this.atoms[i].p;
          p.sub(mwss);
          v2 = null;
          v = this.atoms[i].v;
          if( p.x < 0 ) {
            p.x = -p.x; v.x = -v.x;
            if( v2 === null ) { v2 = v.len2(); }
            v.x += 2.0 * mwdss.x;
          } else if ( p.x > this.ss.x ) {
            p.x = 2.0*this.ss.x - p.x; v.x = -v.x;
            if( v2 === null ) { v2 = v.len2(); }
            v.x -= 2.0 * mwdss.x;
          }
          if( p.y < 0 ) {
            p.y = -p.y; v.y = -v.y;
            if( v2 === null ) { v2 = v.len2(); }
            v.y += 2.0 * mwdss.y;
          } else if ( p.y > this.ss.y ) {
            p.y = 2.0*this.ss.y - p.y; v.y = -v.y;
            if( v2 === null ) { v2 = v.len2(); }
            v.y -= 2.0 * mwdss.y;
          }
          if( p.z < 0 ) {
            p.z = -p.z; v.z = -v.z;
            if( v2 === null ) { v2 = v.len2(); }
            v.z += 2.0 * mwdss.z;
          } else if ( p.z > this.ss.z ) {
            p.z = 2.0*this.ss.z - p.z; v.z = -v.z;
            if( v2 === null ) { v2 = v.len2(); }
            v.z -= 2.0 * mwdss.z;
          }
          // tally work done on the system
          if( v2 !== null ) { 
            mwU += 0.5 * sim.types[this.atoms[i].t].m * (v.len2()-v2); 
          }
        }
        pistonOpt.U += mwU;
        pistonOpt.PdV += this.P*dV;
      }

      // code for the two boundary condition animations in step1
      var bcvis = (function(){
        var c1 = $('#bc_can_period')[0].getContext('2d'), 
            c2 = $('#bc_can_reflect')[0].getContext('2d'),
            x1 = 20, y1 = 20, x2 = 20, y2 = 20,
            vx1 = 1.5, vy1 = 0.87, vx2= 1.5, vy2 = 0.87, r = 10.0, handler;

        function drawAtom(c,x,y) {
          c.beginPath();
          c.arc( x, y, r, 0, Math.PI*2.0, true);
          c.closePath();
          c.fill();
        }
        function step() {
          var i,j;

          // periodic
          c1.fillStyle = "rgba(255,255,255,1)";
          c1.fillRect(0, 0, 50, 50 );
          c1.fillStyle = "rgba(200,0,0,1)";
          for( i = -1; i <=1; ++i ) {
            for( j = -1; j <=1; ++j ) {
              drawAtom(c1,x1+50*i,y1+50*j);
            }
          }
          x1 = ( x1+vx1) % 50;
          y1 = ( y1+vy1) % 50;

          // reflecting
          c2.fillStyle = "rgba(255,255,255,1)";
          c2.fillRect(0, 0, 50, 50 );
          c2.fillStyle = "rgba(200,0,0,1)";
          drawAtom(c2,x2,y2);
          x2 += vx2;
          y2 += vy2;
          if( x2 < r ) {
            vx2 = -vx2;
            x2 = 2*r-x2;
          } else if( x2 > 50-r ) {
            vx2 = -vx2;
            x2 = 2*(50-r)-x2;
          }
          if( y2 < r ) {
            vy2 = -vy2;
            y2 = 2*r-y2;
          } else if( y2 > 50-r ) {
            vy2 = -vy2;
            y2 = 2*(50-r)-y2;
          }

          handler = setTimeout( step, 20 );
        }
        return { start: step, stop: function() { clearTimeout(handler); } }
      })();

      function styleMatrixCell(i,j,cell) {
        cell = cell || $('#mat_'+i+'_'+j);
        if( matrix.form[i] && matrix.form[i][j] ) {
          cell.css( 'backgroundColor', 'green' );
          if( matrix.form[i][j].pot_none ) {
            cell.text('0');
          }
          if( matrix.form[i][j].pot_lj ) {
            cell.text('LJ');
          }
        } else {
          cell.css( 'backgroundColor', '' );
        }
      }
      function saveCell(i,j) {
        if( !matrix.form[i] ) { matrix.form[i] = [] }
        matrix.form[i][j] = saveForm('#potentialform');
      }
      function restoreCell(i,j) {
        if( matrix.form[i] && matrix.form[i][j] ) {
          restoreForm( '#potentialform', matrix.form[i][j] );
        }
      }
      function updateNumEl() {
        var i, j, cell,row, table, numel = parseInt($('#numel option:selected').val());

        function clickMatrix(e,i,j) {
          e.click( function() {
            // save current
            saveCell( matrix.ci, matrix.cj );

            // add symbol for potential
            styleMatrixCell( matrix.ci, matrix.cj );
            $('#mat_'+matrix.ci+'_'+matrix.cj).css( 'border', '' );

            // restore clicked
            $('#mat_'+i+'_'+j).css( { backgroundColor : 'green', border: '2px solid red' } );
            restoreCell(i,j);

            // immediately save cell again in case it did not exist (needed for styleMatrixCell)
            saveCell(i,j);
            styleMatrixCell(i,j);
            updateRadios('#potentialform');

            // switch current
            matrix.ci = i;
            matrix.cj = j;
          } );
        }

        // update element list
        for( i = 0; i < 4; ++i ) {
          if( i >= numel ) {
            elements.li[i].hide();
          } else {
            elements.li[i].show();
          }
        }
        
        // update matrix
        if( numel == 1 ) {
          $('#matrixbox').hide(400);
        } else {
          // save current
          saveCell( matrix.ci, matrix.cj );

          // update interaction matrix widget
          $('#matrixcontainer').empty();
          
          // column heads
          row = $('<tr></tr>').append( $('<th></th>') );
          for( j = 0; j < numel; ++j ) {
            row.append( $('<th></th>').text(j+1) );
          }
          table = $('<table></table>').css( { marginLeft: 'auto', marginRight: 'auto' } ).append(row);

          // body and row heads
          for( i = 0; i < numel; ++i ) {
            row = $('<tr></tr>').append( $('<th></th>').text(i+1) );
            for( j = 0; j < numel; ++j ) {
              if( j < i ){
                cell = $('<th></th>');
              } else {
                cell = $('<td></td>').attr( 'id', 'mat_'+i+'_'+j ).text('X');
                if( i == 0 && j == 0 ) { 
                  cell.css( 'border', '2px solid red' ); 
                } 
                styleMatrixCell( i, j, cell );
                clickMatrix(cell,i,j);
              }
              row.append(cell);
            }
            table.append(row);
          }
          $('#matrixcontainer').append(table);
          $('#matrixbox').show(400);
        }
        matrix.ci = 0;
        matrix.cj = 0;
        restoreCell( matrix.ci, matrix.cj );
      }
      
      function updateRadios(sel) {
        $(sel).find('.radioon').addClass('radiooff').removeClass('radioon');
        $(sel).find('.radiooff').has('input:radio:checked').addClass('radioon').removeClass('radiooff');
      }

      // http://www.webtoolkit.info/javascript-base64.html
      function base64enc(input) {
        var output = "",
            keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
            chr1, chr2, chr3, enc1, enc2, enc3, enc4,
            i = 0;

        while (i < input.length) {
          chr1 = input.charCodeAt(i++);
          chr2 = input.charCodeAt(i++);
          chr3 = input.charCodeAt(i++);

          enc1 = chr1 >> 2;
          enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
          enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
          enc4 = chr3 & 63;

          if (isNaN(chr2)) {
                          enc3 = enc4 = 64;
          } else if (isNaN(chr3)) {
                          enc4 = 64;
          }
          output += keyStr.charAt(enc1) + keyStr.charAt(enc2) +
                    keyStr.charAt(enc3) + keyStr.charAt(enc4);
        }
        return output;
      }

      function saveForm(selector) {
        var data = {};
        $(selector).find('input').each( function(i,e) {
          var id =  $(e).attr('id'), type = $(e).attr('type');
          if( id != '' ) {
            if( type == 'radio' || type == 'checkbox' ) {
              data[id] = $(e).attr('checked');
            } else {
              data[id] = $(e).val();
            }
          }
        } );
        return data;
      }
      function restoreForm(selector,data) {
        $(selector).find('input').each( function(i,e) {
          var id =  $(e).attr('id'), type = $(e).attr('type');
          if( id != '' && data[id] !== undefined ) {
            if( type == 'radio' || type == 'checkbox' ) {
              $(e).attr('checked', data[id] );
            } else {
              $(e).val(data[id]);
            }
          }
        } );
      }
      function profile() {
        var i,min,max,ave,d;
        
        // analyze neighborlist usage
        min = max = ave = sim.nl.data[0].length;
        for( i = 1; i < sim.nl.data.length; ++i ) { 
          d = sim.nl.data[i].length;
          ave += d;
          min = d < min ? d : min;
          max = d > max ? d : max;
        }
        ave /= sim.nl.data.length;
        console.log( 'NL occupancy: min='+min+' max='+max+' average='+ave );


      }
    </script>
  </body>
</html>
